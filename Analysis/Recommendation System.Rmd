---
title: "Recommendation System"
output:
  prettydoc::html_pretty:
    theme: tactile
    highlight: github
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r library, include=FALSE}
library(data.table)
library(tidyverse)
library(recommenderlab)
library(DT)
library(prettydoc)
```


```{r read data, echo=FALSE}
dat <- fread(input = '../Data/wine.clean.csv',verbose = FALSE,na.strings=c(""))
```

```{r constants}
points.name <- "points"
taster.name <- "taster_name"
variety.name <- "variety"

dat <- dat[, mean(get(points.name)), by = .(get(taster.name), get(variety.name))]
setnames(dat, old = c('get','get.1','V1'), new = c('Taster Name','Variety','Point'))

```

```{r real rating class}
# convert into a s4 class 
data_matrix <- as(dat, 'realRatingMatrix')
image(data_matrix[1:19,1:50])
```

```{r train and test split}

set.seed(256)
split <- sample(x = nrow(data_matrix),size = 0.8*nrow(data_matrix))
train <- data_matrix[split,]
test <- data_matrix[-split,]


mean(getRatings(data_matrix), na.rm = TRUE)


es <- evaluationScheme(data_matrix, method = 'split', train = 0.8, given = 5)
```

Calculate a similarity matrix 

```{r similarity matrix}

# similarity matrix using the euclidean distance 
round(similarity(normalize(train[1:7]),method = 'euclidean'),3)

# similarity matrix using the cosine distance
round(similarity(normalize(train[1:7]),method = 'cosine'),3)

# similarity matrix using the pearson distance
round(similarity(normalize(train[1:7]),method = 'pearson'),3)
```


# User Based Collaborative Filter: 


```{r UBCF}
recommenderRegistry$get_entry('UBCF', type = 'realRatingMatrix')

recom.ubcf <- Recommender(train,method='UBCF',parameter = list(method = 'Cosine'))
pred.ubcf <- predict(recom.ubcf,train,n = 1)

as.data.frame(mapply(c, 'Wine Recommendation' = getList(pred.ubcf), 
                     'Wine Rating' = getRatings(pred.ubcf),
                     'Avg Rating' = as.list(rowMeans(train))))

recom.ubcf.2 <- Recommender( data = getData(es, 'train'),
                             method = 'UBCF')

pred.ubcf.2 <- predict(recom.ubcf.2,newdata = getData(es, 'known'), type = 'ratings')

calcPredictionAccuracy(pred.ubcf.2, data = getData(es, 'unknown'))


```

## Popular Methods 

```{r Popular Method}
recommenderRegistry$get_entry("POPULAR", type ="realRatingMatrix")

# recommendation for normal data 
recom.popular <- Recommender(train,method='POPULAR')
pred.popular <- predict(recom.popular,data_matrix, n = 1)

# top recommendation 
data.frame(mapply(c, 'Wine Recommendation' = getList(pred.popular), 
                  'Wine Rating' = getRatings(pred.popular),
                     'Avg Rating' = as.list(rowMeans(train))))

```

Item-based Collaborative Filtering

```{r}

recommenderRegistry$get_entry('IBCF', type = 'realRatingMatrix')

recom.ibcf <- Recommender(train,method='IBCF')
pred.ibcf <- predict(recom.ubcf,train, n = 1, type = 'ratings')

as.data.frame(mapply(c, 'Receommendatoin' = getList(pred.ibcf), 
                     'Wine Rating' = getRatings(pred.ibcf),
                     'Avg Rating' = as.list(rowMeans(train))))


calcPredictionAccuracy(pred.ibcf, test)
```


# Built recommender 


```{r}



```













